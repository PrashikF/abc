 ROUND ROBIN

#include <stdio.h>

int main() {
    int n, i, tq, time = 0, count = 0;
    int bt[10], rt[10], ct[10], wt[10], tat[10];
    float total_wt = 0, total_tat = 0;

    printf("Enter number of processes (max 10): ");
    scanf("%d", &n);

    printf("Enter burst time for each process:\n");
    for (i = 0; i < n; i++) {
        printf("Process %d: ", i + 1);
        scanf("%d", &bt[i]);
        rt[i] = bt[i];  // Copy burst time to remaining time
    }

    printf("Enter time quantum: ");
    scanf("%d", &tq);

    while (1) {
        int done = 1;

        for (i = 0; i < n; i++) {
            if (rt[i] > 0) {
                done = 0;

                if (rt[i] > tq) {
                    time += tq;
                    rt[i] -= tq;
                    printf("Process %d executed for %d units. Time = %d\n", i + 1, tq, time);
                } else {
                    time += rt[i];
                    printf("Process %d executed for %d units. Time = %d (Completed)\n", i + 1, rt[i], time);
 rt[i] = 0;
                    ct[i] = time;
                    tat[i] = ct[i];         // Arrival time = 0
                    wt[i] = tat[i] - bt[i];
                    total_wt += wt[i];
                    total_tat += tat[i];
                    count++;
                }
            }
        }

        if (done == 1)
            break;
    }

    // Output table
    printf("\nP#\tBT\tCT\tTAT\tWT\n");
    for (i = 0; i < n; i++) {
        printf("P%d\t%d\t%d\t%d\t%d\n", i + 1, bt[i], ct[i], tat[i], wt[i]);
    }

    printf("\nAverage Turnaround Time: %.2f\n", total_tat / n);
    printf("Average Waiting Time: %.2f\n", total_wt / n);

    return 0;
}

OUTPUT:

network@network-OEM:~$ nano rr.c
network@network-OEM:~$ gcc rr.c -o rr
network@network-OEM:~$ ./rr
Enter number of processes (max 10): 3
Enter burst time for each process:
Process 1: 10
Process 2: 6
Process 3: 5
Enter time quantum: 4
Process 1 executed for 4 units. Time = 4
Process 2 executed for 4 units. Time = 8
Process 3 executed for 4 units. Time = 12
Process 1 executed for 4 units. Time = 16
Process 2 executed for 2 units. Time = 18 (Completed)
Process 3 executed for 1 units. Time = 19 (Completed)
Process 1 executed for 2 units. Time = 21 (Completed)

P#	BT	CT	TAT	WT
P1	10	21	21	11
P2	6	18	18	12
P3	5	19	19	14

Average Turnaround Time: 19.33
Average Waiting Time: 12.33

________________________________________________________________

#include <stdio.h>   // for printf() and scanf()

int main() {
    int n, i, tq, time = 0, count = 0;
    int bt[10], rt[10], ct[10], wt[10], tat[10]; 
    // bt = burst time, rt = remaining time, 
    // ct = completion time, wt = waiting time, tat = turnaround time

    float total_wt = 0, total_tat = 0;  // to calculate averages later

    // Step 1: take number of processes
    printf("Enter number of processes (max 10): ");
    scanf("%d", &n);

    // Step 2: take burst time (CPU time required) for each process
    printf("Enter burst time for each process:\n");
    for (i = 0; i < n; i++) {
        printf("Process %d: ", i + 1);
        scanf("%d", &bt[i]);   // store burst time
        rt[i] = bt[i];         // initialize remaining time = burst time
    }

    // Step 3: take time quantum (the fixed time slice each process gets)
    printf("Enter time quantum: ");
    scanf("%d", &tq);

    // Step 4: simulate Round Robin scheduling
    // this loop continues until all processes finish
    while (1) {
        int done = 1;   // assume all are done; set to 0 if any process still has time left

        // loop through each process in order
        for (i = 0; i < n; i++) {
            if (rt[i] > 0) {     // if this process still has some time left
                done = 0;        // not done yet, so keep looping

                if (rt[i] > tq) {  // if remaining time is greater than time quantum
                    // process runs only for time quantum
                    time += tq;        // increase total CPU time
                    rt[i] -= tq;       // reduce remaining time
                    printf("Process %d executed for %d units. Time = %d\n",
                           i + 1, tq, time);
                } else {
                    // remaining time is less than or equal to quantum â†’ process finishes
                    time += rt[i];     // add the remaining time to total time
                    printf("Process %d executed for %d units. Time = %d (Completed)\n",
                           i + 1, rt[i], time);
                    rt[i] = 0;         // remaining time becomes 0
                    ct[i] = time;      // completion time recorded

                    // since all processes arrived at time 0:
                    tat[i] = ct[i];             // Turnaround Time = CT - AT = CT
                    wt[i] = tat[i] - bt[i];     // Waiting Time = TAT - BT
                    total_wt += wt[i];          // accumulate totals
                    total_tat += tat[i];
                    count++;                    // count how many finished
                }
            }
        }

        // if all processes are done (done == 1), exit the loop
        if (done == 1)
            break;
    }

    // Step 5: print the results
    printf("\nP#\tBT\tCT\tTAT\tWT\n");
    for (i = 0; i < n; i++) {
        printf("P%d\t%d\t%d\t%d\t%d\n",
               i + 1, bt[i], ct[i], tat[i], wt[i]);
    }

    // Step 6: print average turnaround time and waiting time
    printf("\nAverage Turnaround Time: %.2f\n", total_tat / n);
    printf("Average Waiting Time: %.2f\n", total_wt / n);

    return 0;
}
